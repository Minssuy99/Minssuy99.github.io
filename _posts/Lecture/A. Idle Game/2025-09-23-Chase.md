---
title: 3. Chase
description: Game Development
author: Minssuy99
date: 2025-09-23 19:00:00 +0900
categories: [Lecture, Idle Game]
tags: [C#, Unity]
pin: false
math: true
permalink : /posts/Chase
published: true
# mermaid: false
image:
  path: 'thumbnail.png'
  lqip: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAFCAYAAAB8ZH1oAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsAAAA7AAWrWiQkAAAGHaVRYdFhNTDpjb20uYWRvYmUueG1wAAAAAAA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pg0KPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyI+PHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj48cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0idXVpZDpmYWY1YmRkNS1iYTNkLTExZGEtYWQzMS1kMzNkNzUxODJmMWIiIHhtbG5zOnRpZmY9Imh0dHA6Ly9ucy5hZG9iZS5jb20vdGlmZi8xLjAvIj48dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPjwvcmRmOkRlc2NyaXB0aW9uPjwvcmRmOlJERj48L3g6eG1wbWV0YT4NCjw/eHBhY2tldCBlbmQ9J3cnPz4slJgLAAAAuklEQVQYVwXBMVLCQBSA4f9tNmZ3BAmCEXREL8DYyNBxBK28KS2FjYUHsHPGhgodZ4U40U3e+n1y//CYJtMZRZGjGqnThNwkju0XIQR+6gaTGYy1R1ibEWNL18FFlXPVbvGxxfdLytOS8fgMc30zo9evuKymbF+eeN6sOQxGfOx2FLHGe4dqh3FZzlAC5ymwWC1RsXzvD4jrEZMiSVA1mM+w5/XtncY5mqJifnuHJPCjAcme8PvXIqL8A2tTQzUc0zi5AAAAAElFTkSuQmCC
  # alt:
media_subpath: '/assets/img/posts/Lecture/A. Idle Game'
---

## _**목표**_
---

플레이어와 몬스터 간의 상호 추적 시스템을 구현한다.

플레이어는 가장 가까운 몬스터를 추적하여 공격하고, 몬스터도 가장 가까운 플레이어를 추적하도록 한다.

<br>

## _**리팩토링**_
---

### _**Spawner.cs**_

테스트로 만들었던 `ReturnCoroutine` 함수와 `monster_Prefab` 변수를 삭제한다.

오브젝트 풀링을 통해 몬스터를 생성하므로 `monster_Prefab`은 더 이상 필요하지 않다.

```csharp
public class Spawner : MonoBehaviour
{
    // public GameObject monster_Prefab; 삭제
    .
    .
    IEnumerator SpawnCourtine()
    {
        Vector3 pos;

        for (int i = 0; i < m_Count; i++)
        {
            pos = Vector3.zero + Random.insideUnitSphere * 5.0f;
            pos.y = 0.0f;

            while(Vector3.Distance(pos, Vector3.zero) <= 3.0f)
            {
                pos = Vector3.zero + Random.insideUnitSphere * 5.0f;
                pos.y = 0.0f;
            }

            var goObj = Base_Mng.Pool.Pooling_OBJ("Monster").Get((value) =>
            {
                value.GetComponent<Monster>().Init();
                value.transform.position = pos;
                value.transform.LookAt(Vector3.zero);
            });
            // StartCoroutine(ReturnCoroutine(goObj)); 삭제
        }
        yield return new WaitForSeconds(m_SpawnTime);

        StartCoroutine(SpawnCourtine());
    }
    // ReturnCoroutine 함수 삭제
}
```
{: file="Spawner.cs"}

<br>

### _**Character.cs**_

플레이어와 몬스터가 공통으로 사용할 애니메이션 제어 로직을 `Character.cs` 베이스 클래스로 분리한다.

`HP`, `ATK`, `ATK_Speed` 변수를 `public`으로 선언한 이유는 게임에서 아이템이나 외부 요소에 의해 이 수치들이 변경될 수 있기 때문이다.

```csharp
public class Character : MonoBehaviour
{
    Animator animator;
    
    // 캐릭터 기본 스탯
    public double HP;
    public double ATK;
    public float ATK_Speed;
    
    // 공격 및 추적 범위
    protected float Attack_Range = 3.0f;
    protected float target_Range = 5.0f;
    
    // 추적 대상
    protected Transform m_Target;
    
    // Monster.cs 에 있던 로직
    protected virtual void Start()
    {
        animator = GetComponent<Animator>();
    }

    protected void InitAttack() => isATTACK = false;

    // Monster.cs 에 있던 로직
    protected void AnimatorChange(string temp)
    {
        if(temp == "isATTACK")
        {
            animator.SetTrigger("isATTACK");
            return;
        }
        
        animator.SetBool("isIDLE", false);
        animator.SetBool("isMOVE", false);
        animator.SetBool(temp, true);
    }
}
```
{: file="Character.cs"}

<br>

### _**Monster.cs 수정**_

`Monster` 클래스를 `Character`를 상속받도록 수정한다.

```csharp
public class Monster : Character // inheritance
{
    .
    .
    private void Update()
    {
        transform.LookAt(Vector3.zero);

        if (isSpawn == false)
            return;

        float targetDistance = Vector3.Distance(transform.position, Vector3.zero);

        if (targetDistance <= 0.5f)
        {
            AnimatorChange("isIDLE");
        }
        else
        {
            transform.position = Vector3.MoveTowards(transform.position, Vector3.zero, Time.deltaTime * m_Speed);
            AnimatorChange("isMOVE");
        }
    }
}
```
{: file="Monster.cs"}

<br>

## _**추적**_
---

### _**로직**_

가장 가까운 타겟을 찾는 로직을 작성한다.

```csharp
protected void FindClosestTarget<T>(T[] targets) where T : Component
{
    var enemies = targets;
    Transform closestTarget = null; // 가장 가까운 적의 Transform 를 담을 변수
    float maxDistance = target_Range; // 추적범위

    foreach(var enemy in enemies)
    {
        float targetDistance = Vector3.Distance(transform.position, enemy.transform.position);

        if(targetDistance < maxDistance) // 적이 추적범위 내에 있다면
        {
            closestTarget = enemy.transform; // 가장 근처에 있는 적을 closestTarget 으로 설정
            maxDistance = targetDistance; // maxDistance 를 현재 가까이 있는 적으로 재설정
        }
    }
    m_Target = closestTarget; // 가장 가까운적을 m_Target 으로 설정
    if(m_Target != null) transform.LookAt(m_Target.position); // m_Target 이 있다면 적을 향해 바라봄
}
```
{: file="Character.cs"}

<br>

### _**정적 리스트 추가**_

플레이어와 몬스터를 관리하기 위한 정적 리스트를 `Spawner.cs`에 추가한다.

```csharp
public static List<Monster> m_Monsters = new List<Monster>();
public static List<Player> m_Players = new List<Player>();
```
{: file="Spawner.cs"}

<br>

몬스터가 생성될 때 리스트에 추가하도록 수정한다.

```csharp
var goObj = Base_Mng.Pool.Pooling_OBJ("Monster").Get((value) =>
{
    value.GetComponent<Monster>().Init();
    value.transform.position = pos;
    value.transform.LookAt(Vector3.zero);
    m_Monsters.Add(value.GetComponent<Monster>()); // 리스트에 추가
});
```
{: file="Spawner.cs"}

<br>

### _**Player.cs**_

플레이어의 추적 및 공격 로직을 구현한다.

```csharp
public class Player : Character
{
    // 플레이어의 시작 위치와 회전값 저장
    Vector3 startPos;
    Quaternion rot;

    protected override void Start()
    {
        base.Start(); // 부모 클래스의 Start 함수 호출
        
        startPos = transform.position; // 시작 위치 저장
        rot = transform.rotation; // 시작 회전값 저장
    }

    private void Update()
    {
        // 주변에 몬스터(타겟)가 없다면
        if(m_Target == null)
        {
            // 1. 가장 가까운 타겟을 찾아본다.
            FindClosestTarget(Spawner.m_Monsters.ToArray());
            
            // 2. 시작 위치로 복귀한다
            float targetPos = Vector3.Distance(transform.position, startPos);
            if(targetPos > 0.1f)
            {
                transform.position = Vector3.MoveTowards(transform.position, startPos, Time.deltaTime);
                transform.LookAt(startPos);
                AnimatorChange("isMOVE");
            }
            else
            {
                transform.rotation = rot; // 원래 회전값으로 복구
                AnimatorChange("isIDLE");
            }
            return;
        }
        // m_Target 이 있다면, targetDistance 는 플레이어와 적과의 거리가 된다.
        float targetDistance = Vector3.Distance(transform.position, m_Target.position);
        
        // 타겟이 추적 범위 안에 있지만, 공격 범위 밖이라면
        if(targetDistance <= target_Range && targetDistance > Attack_Range && isATTACK == false)
        {
            AnimatorChange("isMOVE");
            transform.LookAt(m_Target.position);
            transform.position = Vector3.MoveTowards(transform.position, m_Target.position, Time.deltaTime);
        }
        // 타겟이 공격 범위 안에 있고 공격 상태가 아니라면
        else if(targetDistance <= Attack_Range && isATTACK == false)
        {
            isATTACK = true;
            AnimatorChange("isATTACK");
            Invoke("InitAttack", 1.0f); // 1초 후 공격 상태 해제
        }
    }
}
```
{: file="Player.cs"}

<br>

## _**공격**_
---

공격의 로직은 이미 위의 스크립트들에서 추가가 되어있는 상태이다.

여기에 애니메이션에 `Animation Events` 기능을 활용하여 투사체를 날리도록 구현해본다.

![img](2025-09-27-VFX.gif){: .shadow .rounded-10 .w-75 w="1200"}
_Effect_

<br>

투사체로 사용할 `VFX` 파일을 프리팹화 하고, 이름을 `Bullet` 으로 바꾼다.

![img](2025-09-27-Prefab.png){: .shadow .rounded-10 .w-75 w="1200"}
_Prefab_

<br>

플레이어 게임오브젝트에서, 투사체를 날리고 싶은 위치에 빈 오브젝트를 자식으로 생성한다.

![img](2025-09-27-Object.png){: .shadow .rounded-10 .w-75 w="1200"}
_Add Object_

<br>

투사체를 날리고 싶은 위치의 정보를 받기 위해 변수를 추가하고 할당한다.

```csharp
public class Character : MonoBehaviour
{
    [SerializeField] private Transform m_BulletTransform;
}
```
{: file="Character.cs"}

![img](2025-09-27-Variable.png){: .shadow .rounded-10 .w-75 w="1200"}
_Variable_

<br>

애니메이션 파일의 인스펙터를 보면 `Events` 항목이 있다.

`Events` 란, 애니메이션 재생 중 특정 프레임에 함수를 호출할 수 있도록 해주는 기능이다.

원하는 프레임에 우클릭을 하여 아래와 같이 애니메이션에 이벤트를 추가할 수 있다.

![img](2025-09-27-Events.png){: .shadow .rounded-10 .w-75 w="1200"}
_Animation Events_

<br>

이벤트 기능을 활용하기 위해 함수의 이름도 `Bullet` 으로 똑같이 선언한다.

주의할 점은, 애니메이터 컴포넌트가 있는 게임오브젝트에 이벤트 함수가 있는 스크립트도 있어야한다는 것이다.

```csharp
public class Character : MonoBehaviour
{
    protected virtual void Bullet() // Same name
    {
        Base_Mng.Pool.Pooling_OBJ("Bullet").Get((value) =>
        {
            value.transform.position = m_BulletTransform.position;
        });
    }
}
```
{: file="Character.cs"}

<br>

## _**개념**_
---

### _**제네릭 제약 조건**_

`FindClosestTarget` 함수에서 사용한 제네릭 제약 조건은 아래와 같다.

```csharp
protected void FindClosestTarget<T>(T[] targets) where T : Component
```
매개변수 뒤에 붙는 `where` 을 `"T는 ...인 경우에만 허용된다"` 라고 해석하면 쉽다.

| 제약 조건             | 설명                                                        |
|-----------------------|-------------------------------------------------------------|
| `where T : class`     | 참조 타입만 가능                                            |
| `where T : struct`    | 값 타입만 가능                                              |
| `where T : new`       | 매개변수가 없는 기본 생성자를 가진 클래스나 구조체          |
| `where T : Component` | 컴포넌트로 붙일 수 있는 모든 클래스 (Component를 상속받은)  |

<br>

### _**Vector3.MoveTowards**_

_**함수 시그니처**_

```csharp
Vector3.MoveTowards(Vector3 current, Vector3 target, float maxDistanceDelta)
```

_**사용예제**_

```csharp
void Update()
{
    transform.position = Vector3.MoveTowards(transform.position, target.position, time.deltaTime);
}
```

이 함수는 오브젝트를 직접 움직여주는 것이 아니라, 계산만 해줄 뿐이다.

실제로 움직이려면 계산된 결과를 `transform.position`에 대입해야 한다.

* `maxDistanceDelta`: 한 프레임에서 최대로 움직일 수 있는 거리
* 반환값 : `Vector3`

<br>

### _**Animation Events**_

공격 애니메이션에서 특정 프레임에 `Bullet` 함수를 호출하도록 `Animation Event` 를 설정했다.

`Animation Event` 의 조건은 다음과 같다.

* 메서드는 `void` 반환형이어야 한다.
* `string`, `int`, `float`, `object` 타입의 파라미터 전달이 가능하다.
* 스크립트는 애니메이션을 재생하는 `GameObject` 에 붙어있어야 한다.
* 이벤트 이름은 대소문자 정확히 일치해야 한다.

<br>

### _**Invoke**_

공격 쿨타임 구현에 `Invoke`를 사용했는데, 이는 `MonoBehaviour` 에서 제공하는 지연 실행 기능이다.

`Invoke` 함수의 종류는 두개이고, 차이는 아래와 같다.

|구분      |(C#)Delegate Invoke   |Unity's Invoke             |
|----------|----------------------|---------------------------|
|실행      |즉시                  |예약된 시간 이후           |
|호출방법  |실제 함수를 직접 호출 |함수의 이름을 문자열로 전달|
|주요 목적 |이벤트 발생, 콜백 처리|지연실행                   |

<br>

## _**Result**_
---

플레이어는 가장 가까운 몬스터를 추적하여 공격하고, `Bullet` 은 오브젝트 풀로 관리되는 것을 확인할 수 있다.

![img](2025-09-27-result.gif){: .shadow .rounded-10 .w-75 w="1200"}
_Result_